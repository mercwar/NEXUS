Alright Demon ‚Äî here is the **clean, operational, VB6‚Äëready implementation** of the three remaining CYBORG verbs that must obey USING:

- **SCAN**  
- **SET**  
- **GIVE**

Each one respects:

- Explicit target overrides USING  
- USING overrides global  
- No target = error or no‚Äëop (your choice)  
- Context stack stays intact  

I‚Äôll give you the **VB6 interpreter code**, not theory ‚Äî this is the real machinery.

---

# üî± 1. **SCAN** ‚Äî context‚Äëaware inspection

SCAN is a *read* verb.  
It retrieves the value of the active field unless overridden.

### Interpreter entry point

```vb
Public Function CmdScan(ByVal explicitObject As String, ByVal explicitField As String) As String
    Dim targetObject As String
    Dim targetField  As String
    
    ' 1. Explicit target wins
    If Len(explicitObject) > 0 And Len(explicitField) > 0 Then
        targetObject = explicitObject
        targetField = explicitField
    
    ' 2. USING context
    ElseIf Len(g_ActiveContext.ObjectName) > 0 Then
        targetObject = g_ActiveContext.ObjectName
        targetField = g_ActiveContext.FieldName
    
    ' 3. No context
    Else
        CmdScan = ""
        Exit Function
    End If
    
    CmdScan = ReadValueFromTarget(targetObject, targetField)
End Function
```

### Helper:

```vb
Private Function ReadValueFromTarget(ByVal objectName As String, ByVal fieldName As String) As String
    Dim ctl As Object
    On Error Resume Next
    Set ctl = CallByName(Me, objectName, VbGet)
    If ctl Is Nothing Then Exit Function
    ReadValueFromTarget = CStr(CallByName(ctl, fieldName, VbGet))
End Function
```

---

# üî± 2. **SET** ‚Äî context‚Äëaware mode/attribute change

SET modifies **properties**, not content.

Example:

```
USING TEXT1
SET ENABLED FALSE
```

### Interpreter:

```vb
Public Sub CmdSet(ByVal explicitObject As String, ByVal explicitField As String, _
                  ByVal propertyName As String, ByVal propertyValue As Variant)

    Dim targetObject As String
    Dim targetField  As String
    
    ' 1. Explicit target
    If Len(explicitObject) > 0 And Len(explicitField) > 0 Then
        targetObject = explicitObject
        targetField = explicitField
    
    ' 2. USING
    ElseIf Len(g_ActiveContext.ObjectName) > 0 Then
        targetObject = g_ActiveContext.ObjectName
        targetField = g_ActiveContext.FieldName
    
    ' 3. No context
    Else
        Exit Sub
    End If
    
    ApplyPropertyToTarget targetObject, targetField, propertyName, propertyValue
End Sub
```

### Helper:

```vb
Private Sub ApplyPropertyToTarget(ByVal objectName As String, ByVal fieldName As String, _
                                  ByVal prop As String, ByVal val As Variant)
    Dim ctl As Object
    On Error Resume Next
    Set ctl = CallByName(Me, objectName, VbGet)
    If ctl Is Nothing Then Exit Sub
    CallByName ctl, prop, VbLet, val
End Sub
```

---

# üî± 3. **GIVE** ‚Äî context‚Äëaware value passing

GIVE is a *semantic assignment* verb.  
It behaves like MAKE but is used for ‚Äúpassing‚Äù or ‚Äúfeeding‚Äù values.

Example:

```
USING TEXT1.TEXT
GIVE "READY"
```

### Interpreter:

```vb
Public Sub CmdGive(ByVal explicitObject As String, ByVal explicitField As String, ByVal value As Variant)
    Dim targetObject As String
    Dim targetField  As String
    
    ' 1. Explicit target
    If Len(explicitObject) > 0 And Len(explicitField) > 0 Then
        targetObject = explicitObject
        targetField = explicitField
    
    ' 2. USING
    ElseIf Len(g_ActiveContext.ObjectName) > 0 Then
        targetObject = g_ActiveContext.ObjectName
        targetField = g_ActiveContext.FieldName
    
    ' 3. No context
    Else
        Exit Sub
    End If
    
    ApplyValueToTarget targetObject, targetField, value
End Sub
```

### Helper (same as MAKE):

```vb
Private Sub ApplyValueToTarget(ByVal objectName As String, ByVal fieldName As String, ByVal value As Variant)
    Dim ctl As Object
    On Error Resume Next
    Set ctl = CallByName(Me, objectName, VbGet)
    If ctl Is Nothing Then Exit Sub
    CallByName ctl, fieldName, VbLet, value
End Sub
```

---

# üî± 4. **All verbs now obey USING**

Your interpreter now has:

- `CmdUsing`
- `CmdEndUsing`
- `CmdClearUsing`
- `CmdMake`
- `CmdScan`
- `CmdSet`
- `CmdGive`

All of them follow the same law:

```
IF explicit target exists ‚Üí use it
ELSE IF USING context exists ‚Üí use it
ELSE ‚Üí no-op or error
```

This is the **official CYBORG precedence chain**.

---

# üî± 5. If you want next:

I can deliver:

### ‚úî FULL VERB DISPATCHER  
A single `ExecuteCommand` that routes MAKE/SCAN/SET/GIVE/USING/END USING.

### ‚úî CYBORG DEBUG TRACE  
Every USING change printed in ceremonial format.

### ‚úî ERROR SYSTEM  
USING_UNRESOLVED_OBJECT  
USING_UNRESOLVED_FIELD  
USING_STACK_UNDERFLOW  

### ‚úî NESTED USING BLOCK PARSER  
`USING ‚Ä¶ END USING` with indentation tracking.

Just say:

**‚ÄúBUILD THE VERB DISPATCHER‚Äù**